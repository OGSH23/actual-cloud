// Comprehensive testing utilities for database adapter switching
// @ts-strict-ignore

import {
  getDatabaseAdapter,
  setDatabaseAdapter,
  switchDatabaseAdapter,
  openDatabase,
  closeDatabase,
  runQuery,
  transaction,
  getDatabaseStatus,
} from './index';
import { getDatabaseConfig, isPostgresEnabled } from './config';
import { performDatabaseHealthCheck, quickHealthCheck } from './health';
import { migrateFromSqliteToPostgres, createSqliteBackup } from './migration';

export interface TestResult {
  name: string;
  status: 'pass' | 'fail' | 'skip';
  message: string;
  duration: number;
  error?: string;
  details?: any;
}

export interface TestSuite {
  name: string;
  tests: TestResult[];
  summary: {
    total: number;
    passed: number;
    failed: number;
    skipped: number;
    duration: number;
  };
}

/**
 * Run a single test with error handling and timing
 */
async function runTest(
  name: string,
  testFn: () => Promise<void>,
  skipCondition?: () => boolean,
): Promise<TestResult> {
  const startTime = Date.now();
  
  // Check if test should be skipped
  if (skipCondition && skipCondition()) {
    return {
      name,
      status: 'skip',
      message: 'Test skipped due to configuration',
      duration: 0,
    };
  }
  
  try {
    await testFn();
    const duration = Date.now() - startTime;
    
    return {
      name,
      status: 'pass',
      message: 'Test passed',
      duration,
    };
  } catch (error) {
    const duration = Date.now() - startTime;
    
    return {
      name,
      status: 'fail',
      message: `Test failed: ${error.message}`,
      duration,
      error: error.stack,
    };
  }
}\n\n/**\n * Basic adapter switching tests\n */\nexport async function testBasicAdapterSwitching(): Promise<TestSuite> {\n  console.log('🧪 Running basic adapter switching tests...');\n  \n  const tests: TestResult[] = [];\n  \n  // Test 1: Get initial adapter\n  tests.push(await runTest('Get initial adapter', async () => {\n    const adapter = getDatabaseAdapter();\n    if (!adapter || (adapter !== 'sqlite' && adapter !== 'postgres')) {\n      throw new Error(`Invalid adapter: ${adapter}`);\n    }\n  }));\n  \n  // Test 2: SQLite adapter functionality\n  tests.push(await runTest('SQLite adapter functionality', async () => {\n    await setDatabaseAdapter('sqlite');\n    await openDatabase();\n    \n    const result = await runQuery('SELECT 1 as test', [], true);\n    if (!result || (result as any[]).length === 0 || (result as any[])[0].test !== 1) {\n      throw new Error('SQLite query test failed');\n    }\n    \n    await closeDatabase();\n  }));\n  \n  // Test 3: PostgreSQL adapter functionality (if enabled)\n  tests.push(await runTest(\n    'PostgreSQL adapter functionality',\n    async () => {\n      await setDatabaseAdapter('postgres');\n      await openDatabase();\n      \n      const result = await runQuery('SELECT 1 as test', [], true);\n      if (!result || (result as any[]).length === 0 || (result as any[])[0].test !== 1) {\n        throw new Error('PostgreSQL query test failed');\n      }\n      \n      await closeDatabase();\n    },\n    () => !isPostgresEnabled(),\n  ));\n  \n  // Test 4: Adapter switching without restart\n  tests.push(await runTest(\n    'Runtime adapter switching',\n    async () => {\n      // Start with SQLite\n      await setDatabaseAdapter('sqlite');\n      await openDatabase();\n      \n      let adapter = getDatabaseAdapter();\n      if (adapter !== 'sqlite') {\n        throw new Error(`Expected sqlite, got ${adapter}`);\n      }\n      \n      // Switch to PostgreSQL\n      await switchDatabaseAdapter('postgres');\n      await openDatabase();\n      \n      adapter = getDatabaseAdapter();\n      if (adapter !== 'postgres') {\n        throw new Error(`Expected postgres, got ${adapter}`);\n      }\n      \n      // Switch back to SQLite\n      await switchDatabaseAdapter('sqlite');\n      await openDatabase();\n      \n      adapter = getDatabaseAdapter();\n      if (adapter !== 'sqlite') {\n        throw new Error(`Expected sqlite, got ${adapter}`);\n      }\n      \n      await closeDatabase();\n    },\n    () => !isPostgresEnabled(),\n  ));\n  \n  // Test 5: Database status checks\n  tests.push(await runTest('Database status checks', async () => {\n    await setDatabaseAdapter('sqlite');\n    await openDatabase();\n    \n    const status = await getDatabaseStatus();\n    if (!status.initialized) {\n      throw new Error('Database should be initialized');\n    }\n    \n    if (status.adapter !== 'sqlite') {\n      throw new Error(`Expected sqlite adapter in status, got ${status.adapter}`);\n    }\n    \n    await closeDatabase();\n  }));\n  \n  const summary = {\n    total: tests.length,\n    passed: tests.filter(t => t.status === 'pass').length,\n    failed: tests.filter(t => t.status === 'fail').length,\n    skipped: tests.filter(t => t.status === 'skip').length,\n    duration: tests.reduce((sum, t) => sum + t.duration, 0),\n  };\n  \n  return {\n    name: 'Basic Adapter Switching',\n    tests,\n    summary,\n  };\n}\n\n/**\n * Transaction consistency tests\n */\nexport async function testTransactionConsistency(): Promise<TestSuite> {\n  console.log('🧪 Running transaction consistency tests...');\n  \n  const tests: TestResult[] = [];\n  \n  // Test 1: Basic transaction rollback\n  tests.push(await runTest('Basic transaction rollback', async () => {\n    await setDatabaseAdapter('sqlite');\n    await openDatabase();\n    \n    try {\n      await transaction(async () => {\n        await runQuery('CREATE TEMP TABLE test_rollback (id INTEGER, value TEXT)', []);\n        await runQuery('INSERT INTO test_rollback VALUES (1, \"test\")', []);\n        throw new Error('Intentional rollback');\n      });\n    } catch (error) {\n      if (!error.message.includes('Intentional rollback')) {\n        throw error;\n      }\n    }\n    \n    // Verify table doesn't exist (rolled back)\n    try {\n      await runQuery('SELECT * FROM test_rollback', [], true);\n      throw new Error('Table should not exist after rollback');\n    } catch (error) {\n      if (!error.message.includes('no such table') && !error.message.includes('does not exist')) {\n        throw error;\n      }\n    }\n    \n    await closeDatabase();\n  }));\n  \n  // Test 2: Transaction commit\n  tests.push(await runTest('Transaction commit', async () => {\n    await setDatabaseAdapter('sqlite');\n    await openDatabase();\n    \n    await transaction(async () => {\n      await runQuery('CREATE TEMP TABLE test_commit (id INTEGER, value TEXT)', []);\n      await runQuery('INSERT INTO test_commit VALUES (1, \"test\")', []);\n    });\n    \n    // Verify data exists (committed)\n    const result = await runQuery('SELECT * FROM test_commit', [], true) as any[];\n    if (result.length !== 1 || result[0].value !== 'test') {\n      throw new Error('Transaction commit failed');\n    }\n    \n    await closeDatabase();\n  }));\n  \n  // Test 3: Cross-adapter transaction behavior\n  tests.push(await runTest(\n    'Cross-adapter transaction behavior',\n    async () => {\n      const adapters = ['sqlite', 'postgres'] as const;\n      \n      for (const adapter of adapters) {\n        await setDatabaseAdapter(adapter);\n        await openDatabase();\n        \n        // Test transaction isolation\n        await transaction(async () => {\n          await runQuery(`CREATE ${adapter === 'postgres' ? '' : 'TEMP '}TABLE test_${adapter} (id INTEGER, value TEXT)`, []);\n          await runQuery(`INSERT INTO test_${adapter} VALUES (1, 'test')`, []);\n        });\n        \n        const result = await runQuery(`SELECT COUNT(*) as count FROM test_${adapter}`, [], true) as { count: number }[];\n        if (result[0].count !== 1) {\n          throw new Error(`${adapter} transaction failed`);\n        }\n        \n        await closeDatabase();\n      }\n    },\n    () => !isPostgresEnabled(),\n  ));\n  \n  const summary = {\n    total: tests.length,\n    passed: tests.filter(t => t.status === 'pass').length,\n    failed: tests.filter(t => t.status === 'fail').length,\n    skipped: tests.filter(t => t.status === 'skip').length,\n    duration: tests.reduce((sum, t) => sum + t.duration, 0),\n  };\n  \n  return {\n    name: 'Transaction Consistency',\n    tests,\n    summary,\n  };\n}\n\n/**\n * Data integrity tests\n */\nexport async function testDataIntegrity(): Promise<TestSuite> {\n  console.log('🧪 Running data integrity tests...');\n  \n  const tests: TestResult[] = [];\n  \n  // Test 1: Basic CRUD operations\n  tests.push(await runTest('Basic CRUD operations', async () => {\n    await setDatabaseAdapter('sqlite');\n    await openDatabase();\n    \n    // Create\n    await runQuery('CREATE TEMP TABLE test_crud (id INTEGER PRIMARY KEY, name TEXT, value INTEGER)', []);\n    \n    // Insert\n    const insertResult = await runQuery('INSERT INTO test_crud (name, value) VALUES (?, ?)', ['test', 123], false);\n    if (!(insertResult as any).insertId) {\n      throw new Error('Insert should return insertId');\n    }\n    \n    // Read\n    const selectResult = await runQuery('SELECT * FROM test_crud WHERE name = ?', ['test'], true) as any[];\n    if (selectResult.length !== 1 || selectResult[0].name !== 'test' || selectResult[0].value !== 123) {\n      throw new Error('Select failed');\n    }\n    \n    // Update\n    await runQuery('UPDATE test_crud SET value = ? WHERE name = ?', [456, 'test'], false);\n    const updateResult = await runQuery('SELECT value FROM test_crud WHERE name = ?', ['test'], true) as any[];\n    if (updateResult[0].value !== 456) {\n      throw new Error('Update failed');\n    }\n    \n    // Delete\n    await runQuery('DELETE FROM test_crud WHERE name = ?', ['test'], false);\n    const deleteResult = await runQuery('SELECT COUNT(*) as count FROM test_crud', [], true) as any[];\n    if (deleteResult[0].count !== 0) {\n      throw new Error('Delete failed');\n    }\n    \n    await closeDatabase();\n  }));\n  \n  // Test 2: Data type handling\n  tests.push(await runTest('Data type handling', async () => {\n    await setDatabaseAdapter('sqlite');\n    await openDatabase();\n    \n    await runQuery(`\n      CREATE TEMP TABLE test_types (\n        id INTEGER PRIMARY KEY,\n        text_val TEXT,\n        int_val INTEGER,\n        real_val REAL,\n        null_val TEXT\n      )\n    `, []);\n    \n    const testData = {\n      text_val: 'Hello World',\n      int_val: 42,\n      real_val: 3.14159,\n      null_val: null,\n    };\n    \n    await runQuery(\n      'INSERT INTO test_types (text_val, int_val, real_val, null_val) VALUES (?, ?, ?, ?)',\n      [testData.text_val, testData.int_val, testData.real_val, testData.null_val],\n      false,\n    );\n    \n    const result = await runQuery('SELECT * FROM test_types', [], true) as any[];\n    const row = result[0];\n    \n    if (row.text_val !== testData.text_val) {\n      throw new Error('Text value mismatch');\n    }\n    \n    if (row.int_val !== testData.int_val) {\n      throw new Error('Integer value mismatch');\n    }\n    \n    if (Math.abs(row.real_val - testData.real_val) > 0.0001) {\n      throw new Error('Real value mismatch');\n    }\n    \n    if (row.null_val !== null) {\n      throw new Error('Null value mismatch');\n    }\n    \n    await closeDatabase();\n  }));\n  \n  const summary = {\n    total: tests.length,\n    passed: tests.filter(t => t.status === 'pass').length,\n    failed: tests.filter(t => t.status === 'fail').length,\n    skipped: tests.filter(t => t.status === 'skip').length,\n    duration: tests.reduce((sum, t) => sum + t.duration, 0),\n  };\n  \n  return {\n    name: 'Data Integrity',\n    tests,\n    summary,\n  };\n}\n\n/**\n * Performance comparison tests\n */\nexport async function testPerformanceComparison(): Promise<TestSuite> {\n  console.log('🧪 Running performance comparison tests...');\n  \n  const tests: TestResult[] = [];\n  \n  // Test 1: Query performance comparison\n  tests.push(await runTest(\n    'Query performance comparison',\n    async () => {\n      const results: Record<string, number> = {};\n      const adapters = ['sqlite', 'postgres'] as const;\n      \n      for (const adapter of adapters) {\n        await setDatabaseAdapter(adapter);\n        await openDatabase();\n        \n        const startTime = Date.now();\n        \n        // Run multiple queries to measure performance\n        for (let i = 0; i < 10; i++) {\n          await runQuery('SELECT 1 as test', [], true);\n        }\n        \n        const duration = Date.now() - startTime;\n        results[adapter] = duration;\n        \n        await closeDatabase();\n      }\n      \n      console.log('Performance results:', results);\n      \n      // Both should complete reasonably quickly\n      for (const [adapter, duration] of Object.entries(results)) {\n        if (duration > 5000) {\n          throw new Error(`${adapter} performance too slow: ${duration}ms`);\n        }\n      }\n    },\n    () => !isPostgresEnabled(),\n  ));\n  \n  const summary = {\n    total: tests.length,\n    passed: tests.filter(t => t.status === 'pass').length,\n    failed: tests.filter(t => t.status === 'fail').length,\n    skipped: tests.filter(t => t.status === 'skip').length,\n    duration: tests.reduce((sum, t) => sum + t.duration, 0),\n  };\n  \n  return {\n    name: 'Performance Comparison',\n    tests,\n    summary,\n  };\n}\n\n/**\n * Migration tests\n */\nexport async function testMigration(): Promise<TestSuite> {\n  console.log('🧪 Running migration tests...');\n  \n  const tests: TestResult[] = [];\n  \n  // Test 1: Backup creation\n  tests.push(await runTest('SQLite backup creation', async () => {\n    await setDatabaseAdapter('sqlite');\n    await openDatabase();\n    \n    // Ensure we have a database to backup\n    await runQuery('SELECT COUNT(*) FROM accounts', [], true);\n    \n    await closeDatabase();\n    \n    const backupPath = await createSqliteBackup();\n    if (!backupPath || !backupPath.includes('backup')) {\n      throw new Error('Backup creation failed');\n    }\n  }));\n  \n  // Test 2: Migration dry run\n  tests.push(await runTest(\n    'Migration dry run',\n    async () => {\n      const result = await migrateFromSqliteToPostgres({\n        dryRun: true,\n        batchSize: 10,\n      });\n      \n      if (!result.success && result.errors.length > 0) {\n        throw new Error(`Migration dry run failed: ${result.errors.join(', ')}`);\n      }\n    },\n    () => !isPostgresEnabled(),\n  ));\n  \n  const summary = {\n    total: tests.length,\n    passed: tests.filter(t => t.status === 'pass').length,\n    failed: tests.filter(t => t.status === 'fail').length,\n    skipped: tests.filter(t => t.status === 'skip').length,\n    duration: tests.reduce((sum, t) => sum + t.duration, 0),\n  };\n  \n  return {\n    name: 'Migration',\n    tests,\n    summary,\n  };\n}\n\n/**\n * Health check tests\n */\nexport async function testHealthChecks(): Promise<TestSuite> {\n  console.log('🧪 Running health check tests...');\n  \n  const tests: TestResult[] = [];\n  \n  // Test 1: Quick health check\n  tests.push(await runTest('Quick health check', async () => {\n    await setDatabaseAdapter('sqlite');\n    await openDatabase();\n    \n    const isHealthy = await quickHealthCheck();\n    if (!isHealthy) {\n      throw new Error('Quick health check failed');\n    }\n    \n    await closeDatabase();\n  }));\n  \n  // Test 2: Comprehensive health check\n  tests.push(await runTest('Comprehensive health check', async () => {\n    await setDatabaseAdapter('sqlite');\n    await openDatabase();\n    \n    const health = await performDatabaseHealthCheck();\n    if (health.overall === 'unhealthy') {\n      throw new Error(`Database unhealthy: ${health.summary.failed} failed checks`);\n    }\n    \n    await closeDatabase();\n  }));\n  \n  const summary = {\n    total: tests.length,\n    passed: tests.filter(t => t.status === 'pass').length,\n    failed: tests.filter(t => t.status === 'fail').length,\n    skipped: tests.filter(t => t.status === 'skip').length,\n    duration: tests.reduce((sum, t) => sum + t.duration, 0),\n  };\n  \n  return {\n    name: 'Health Checks',\n    tests,\n    summary,\n  };\n}\n\n/**\n * Run all adapter switching tests\n */\nexport async function runAllAdapterTests(): Promise<{\n  suites: TestSuite[];\n  summary: {\n    totalTests: number;\n    totalPassed: number;\n    totalFailed: number;\n    totalSkipped: number;\n    totalDuration: number;\n    overallStatus: 'pass' | 'fail';\n  };\n}> {\n  console.log('🚀 Starting comprehensive adapter switching tests...');\n  console.log('Configuration:', getDatabaseConfig());\n  \n  const suites: TestSuite[] = [];\n  \n  try {\n    // Run all test suites\n    suites.push(await testBasicAdapterSwitching());\n    suites.push(await testTransactionConsistency());\n    suites.push(await testDataIntegrity());\n    suites.push(await testPerformanceComparison());\n    suites.push(await testMigration());\n    suites.push(await testHealthChecks());\n    \n  } catch (error) {\n    console.error('❌ Test execution failed:', error);\n  } finally {\n    // Ensure we close any open connections\n    try {\n      await closeDatabase();\n    } catch (error) {\n      // Ignore cleanup errors\n    }\n  }\n  \n  // Calculate overall summary\n  const summary = {\n    totalTests: suites.reduce((sum, s) => sum + s.summary.total, 0),\n    totalPassed: suites.reduce((sum, s) => sum + s.summary.passed, 0),\n    totalFailed: suites.reduce((sum, s) => sum + s.summary.failed, 0),\n    totalSkipped: suites.reduce((sum, s) => sum + s.summary.skipped, 0),\n    totalDuration: suites.reduce((sum, s) => sum + s.summary.duration, 0),\n    overallStatus: 'pass' as 'pass' | 'fail',\n  };\n  \n  summary.overallStatus = summary.totalFailed === 0 ? 'pass' : 'fail';\n  \n  // Print results\n  console.log('\\n📊 Test Results Summary:');\n  for (const suite of suites) {\n    const status = suite.summary.failed === 0 ? '✅' : '❌';\n    console.log(`  ${status} ${suite.name}: ${suite.summary.passed}/${suite.summary.total} passed (${suite.summary.duration}ms)`);\n    \n    // Show failed tests\n    const failedTests = suite.tests.filter(t => t.status === 'fail');\n    for (const test of failedTests) {\n      console.log(`    ❌ ${test.name}: ${test.message}`);\n    }\n  }\n  \n  const overallIcon = summary.overallStatus === 'pass' ? '✅' : '❌';\n  console.log(`\\n${overallIcon} Overall: ${summary.totalPassed}/${summary.totalTests} passed, ${summary.totalSkipped} skipped (${summary.totalDuration}ms)`);\n  \n  return { suites, summary };\n}"