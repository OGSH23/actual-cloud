// PostgreSQL integration with runtime adapter switching
// @ts-strict-ignore

import {
  getDatabaseAdapter,
  setDatabaseAdapter,
  switchDatabaseAdapter,
  openDatabase,
  closeDatabase,
  getDatabaseStatus,
} from './index';
import {
  getDatabaseConfig,
  getConfigSummary,
  isPostgresEnabled,
  isFallbackToSqliteEnabled,
  areHealthChecksEnabled,
} from './config';
import { performDatabaseHealthCheck, DatabaseHealthMonitor } from './health';
import { migrateFromSqliteToPostgres, createSqliteBackup } from './migration';
import { runAllAdapterTests } from './test-adapter-switching';

export interface PostgresIntegrationOptions {
  autoMigrate?: boolean;
  createBackup?: boolean;
  runHealthChecks?: boolean;
  startMonitoring?: boolean;
  monitoringInterval?: number;
  testConnection?: boolean;
}

export interface PostgresIntegrationResult {
  success: boolean;
  adapter: string;
  migrated?: boolean;
  backupPath?: string;
  healthStatus?: any;
  errors: string[];
  warnings: string[];
}

/**
 * Initialize PostgreSQL integration with comprehensive setup
 */
export async function initializePostgresIntegration(
  options: PostgresIntegrationOptions = {},
): Promise<PostgresIntegrationResult> {
  const errors: string[] = [];
  const warnings: string[] = [];
  let migrated = false;
  let backupPath: string | undefined;
  let healthStatus: any;
  
  console.log('üöÄ Initializing PostgreSQL integration...');
  console.log(getConfigSummary());
  
  try {\n    // Step 1: Check if PostgreSQL is enabled\n    if (!isPostgresEnabled()) {\n      const message = 'PostgreSQL not enabled. Set ENABLE_POSTGRES=true or DATABASE_ADAPTER=postgres';\n      console.log(`‚ÑπÔ∏è ${message}`);\n      warnings.push(message);\n      \n      return {\n        success: true,\n        adapter: getDatabaseAdapter(),\n        errors,\n        warnings,\n      };\n    }\n    \n    // Step 2: Test PostgreSQL connection\n    if (options.testConnection !== false) {\n      console.log('üîç Testing PostgreSQL connection...');\n      \n      try {\n        await setDatabaseAdapter('postgres');\n        await openDatabase();\n        \n        // Test basic connectivity\n        const status = await getDatabaseStatus();\n        if (!status.initialized) {\n          throw new Error('PostgreSQL connection test failed');\n        }\n        \n        console.log('‚úÖ PostgreSQL connection test successful');\n        await closeDatabase();\n      } catch (error) {\n        const errorMsg = `PostgreSQL connection failed: ${error.message}`;\n        console.error(`‚ùå ${errorMsg}`);\n        \n        if (isFallbackToSqliteEnabled()) {\n          console.log('üîÑ Falling back to SQLite...');\n          await setDatabaseAdapter('sqlite');\n          warnings.push(`${errorMsg} (fell back to SQLite)`);\n        } else {\n          errors.push(errorMsg);\n          throw new Error(errorMsg);\n        }\n      }\n    }\n    \n    // Step 3: Create backup if requested\n    if (options.createBackup && getDatabaseAdapter() === 'postgres') {\n      console.log('üíæ Creating SQLite backup before migration...');\n      try {\n        backupPath = await createSqliteBackup();\n        console.log(`‚úÖ Backup created: ${backupPath}`);\n      } catch (error) {\n        const warningMsg = `Backup creation failed: ${error.message}`;\n        console.warn(`‚ö†Ô∏è ${warningMsg}`);\n        warnings.push(warningMsg);\n      }\n    }\n    \n    // Step 4: Auto-migrate if requested\n    if (options.autoMigrate && getDatabaseAdapter() === 'postgres') {\n      console.log('üîÑ Running automatic migration from SQLite to PostgreSQL...');\n      \n      try {\n        const migrationResult = await migrateFromSqliteToPostgres({\n          batchSize: 1000,\n          validateData: true,\n          onProgress: (progress) => {\n            if (progress.completedTables % 5 === 0 || progress.completedTables === progress.totalTables) {\n              console.log(`üìä Migration progress: ${progress.completedTables}/${progress.totalTables} tables, ${progress.migratedRows} rows`);\n            }\n          },\n        });\n        \n        if (migrationResult.success) {\n          console.log(`‚úÖ Migration completed: ${migrationResult.migratedTables.length} tables, ${migrationResult.totalRows} rows`);\n          migrated = true;\n        } else {\n          const errorMsg = `Migration failed: ${migrationResult.errors.join(', ')}`;\n          console.error(`‚ùå ${errorMsg}`);\n          warnings.push(errorMsg);\n        }\n      } catch (error) {\n        const errorMsg = `Migration error: ${error.message}`;\n        console.error(`‚ùå ${errorMsg}`);\n        warnings.push(errorMsg);\n      }\n    }\n    \n    // Step 5: Run health checks\n    if (options.runHealthChecks !== false && areHealthChecksEnabled()) {\n      console.log('üîç Running health checks...');\n      \n      try {\n        await openDatabase();\n        healthStatus = await performDatabaseHealthCheck();\n        \n        if (healthStatus.overall === 'unhealthy') {\n          const warningMsg = `Database health check failed: ${healthStatus.summary.failed} failed checks`;\n          console.warn(`‚ö†Ô∏è ${warningMsg}`);\n          warnings.push(warningMsg);\n        }\n        \n        await closeDatabase();\n      } catch (error) {\n        const warningMsg = `Health check failed: ${error.message}`;\n        console.warn(`‚ö†Ô∏è ${warningMsg}`);\n        warnings.push(warningMsg);\n      }\n    }\n    \n    // Step 6: Start monitoring if requested\n    if (options.startMonitoring && areHealthChecksEnabled()) {\n      console.log('üìä Starting database health monitoring...');\n      \n      const monitor = new DatabaseHealthMonitor((health) => {\n        console.log(`üìä Health status: ${health.overall} (${health.summary.passed}/${health.checks.length} checks passed)`);\n        \n        if (health.overall === 'unhealthy') {\n          console.warn('‚ö†Ô∏è Database health degraded - manual intervention may be required');\n        }\n      });\n      \n      monitor.start(options.monitoringInterval || 60000);\n    }\n    \n    console.log('‚úÖ PostgreSQL integration initialization completed');\n    \n    return {\n      success: true,\n      adapter: getDatabaseAdapter(),\n      migrated,\n      backupPath,\n      healthStatus,\n      errors,\n      warnings,\n    };\n    \n  } catch (error) {\n    const errorMsg = `PostgreSQL integration failed: ${error.message}`;\n    console.error(`‚ùå ${errorMsg}`);\n    errors.push(errorMsg);\n    \n    return {\n      success: false,\n      adapter: getDatabaseAdapter(),\n      migrated,\n      backupPath,\n      healthStatus,\n      errors,\n      warnings,\n    };\n  }\n}\n\n/**\n * Switch to PostgreSQL with comprehensive migration\n */\nexport async function switchToPostgres(options: {\n  createBackup?: boolean;\n  migrateData?: boolean;\n  validateMigration?: boolean;\n} = {}): Promise<PostgresIntegrationResult> {\n  console.log('üîÑ Switching to PostgreSQL...');\n  \n  const errors: string[] = [];\n  const warnings: string[] = [];\n  let backupPath: string | undefined;\n  let migrated = false;\n  \n  try {\n    // Create backup if requested\n    if (options.createBackup !== false) {\n      console.log('üíæ Creating SQLite backup...');\n      backupPath = await createSqliteBackup();\n    }\n    \n    // Switch adapter\n    await switchDatabaseAdapter('postgres');\n    await openDatabase();\n    \n    // Migrate data if requested\n    if (options.migrateData) {\n      console.log('üîÑ Migrating data to PostgreSQL...');\n      \n      const migrationResult = await migrateFromSqliteToPostgres({\n        validateData: options.validateMigration,\n        batchSize: 1000,\n      });\n      \n      if (migrationResult.success) {\n        migrated = true;\n        console.log('‚úÖ Data migration completed');\n      } else {\n        warnings.push(`Migration completed with errors: ${migrationResult.errors.join(', ')}`);\n      }\n    }\n    \n    await closeDatabase();\n    \n    return {\n      success: true,\n      adapter: 'postgres',\n      migrated,\n      backupPath,\n      errors,\n      warnings,\n    };\n    \n  } catch (error) {\n    const errorMsg = `Switch to PostgreSQL failed: ${error.message}`;\n    console.error(`‚ùå ${errorMsg}`);\n    errors.push(errorMsg);\n    \n    // Attempt fallback to SQLite\n    if (isFallbackToSqliteEnabled()) {\n      console.log('üîÑ Falling back to SQLite...');\n      try {\n        await switchDatabaseAdapter('sqlite');\n        warnings.push('Fell back to SQLite after PostgreSQL failure');\n      } catch (fallbackError) {\n        errors.push(`Fallback to SQLite failed: ${fallbackError.message}`);\n      }\n    }\n    \n    return {\n      success: false,\n      adapter: getDatabaseAdapter(),\n      migrated,\n      backupPath,\n      errors,\n      warnings,\n    };\n  }\n}\n\n/**\n * Switch back to SQLite\n */\nexport async function switchToSqlite(): Promise<PostgresIntegrationResult> {\n  console.log('üîÑ Switching to SQLite...');\n  \n  const errors: string[] = [];\n  const warnings: string[] = [];\n  \n  try {\n    await switchDatabaseAdapter('sqlite');\n    await openDatabase();\n    await closeDatabase();\n    \n    console.log('‚úÖ Switched to SQLite');\n    \n    return {\n      success: true,\n      adapter: 'sqlite',\n      errors,\n      warnings,\n    };\n    \n  } catch (error) {\n    const errorMsg = `Switch to SQLite failed: ${error.message}`;\n    console.error(`‚ùå ${errorMsg}`);\n    errors.push(errorMsg);\n    \n    return {\n      success: false,\n      adapter: getDatabaseAdapter(),\n      errors,\n      warnings,\n    };\n  }\n}\n\n/**\n * Run comprehensive tests for PostgreSQL integration\n */\nexport async function testPostgresIntegration(): Promise<{\n  success: boolean;\n  results: any;\n  duration: number;\n}> {\n  console.log('üß™ Running comprehensive PostgreSQL integration tests...');\n  \n  const startTime = Date.now();\n  \n  try {\n    const results = await runAllAdapterTests();\n    const duration = Date.now() - startTime;\n    \n    const success = results.summary.overallStatus === 'pass';\n    \n    console.log(`${success ? '‚úÖ' : '‚ùå'} PostgreSQL integration tests completed in ${duration}ms`);\n    \n    return {\n      success,\n      results,\n      duration,\n    };\n    \n  } catch (error) {\n    const duration = Date.now() - startTime;\n    console.error('‚ùå PostgreSQL integration tests failed:', error);\n    \n    return {\n      success: false,\n      results: { error: error.message },\n      duration,\n    };\n  }\n}\n\n/**\n * Get current integration status\n */\nexport async function getIntegrationStatus(): Promise<{\n  adapter: string;\n  postgres: {\n    enabled: boolean;\n    connected: boolean;\n    healthy?: boolean;\n  };\n  sqlite: {\n    available: boolean;\n    connected: boolean;\n  };\n  migration: {\n    required: boolean;\n    possible: boolean;\n  };\n}> {\n  const currentAdapter = getDatabaseAdapter();\n  const postgresEnabled = isPostgresEnabled();\n  \n  // Test PostgreSQL connection\n  let postgresConnected = false;\n  let postgresHealthy = false;\n  \n  if (postgresEnabled) {\n    try {\n      await setDatabaseAdapter('postgres');\n      await openDatabase();\n      postgresConnected = true;\n      \n      if (areHealthChecksEnabled()) {\n        const health = await performDatabaseHealthCheck();\n        postgresHealthy = health.overall !== 'unhealthy';\n      }\n      \n      await closeDatabase();\n    } catch (error) {\n      // PostgreSQL not available\n    }\n  }\n  \n  // Test SQLite connection\n  let sqliteConnected = false;\n  \n  try {\n    await setDatabaseAdapter('sqlite');\n    await openDatabase();\n    sqliteConnected = true;\n    await closeDatabase();\n  } catch (error) {\n    // SQLite not available\n  }\n  \n  // Restore original adapter\n  await setDatabaseAdapter(currentAdapter);\n  \n  return {\n    adapter: currentAdapter,\n    postgres: {\n      enabled: postgresEnabled,\n      connected: postgresConnected,\n      healthy: postgresHealthy,\n    },\n    sqlite: {\n      available: true, // SQLite should always be available\n      connected: sqliteConnected,\n    },\n    migration: {\n      required: postgresEnabled && currentAdapter === 'sqlite',\n      possible: postgresConnected && sqliteConnected,\n    },\n  };\n}\n\n// Export convenience functions\nexport {\n  getDatabaseAdapter,\n  switchDatabaseAdapter,\n  getDatabaseStatus,\n  performDatabaseHealthCheck,\n  migrateFromSqliteToPostgres,\n  createSqliteBackup,\n} from './index';\n\nexport {\n  getDatabaseConfig,\n  getConfigSummary,\n  isPostgresEnabled,\n  isFallbackToSqliteEnabled,\n} from './config';"